bl_info = {
    "name": "A2F Import Weights",
    "blender": (3, 6, 0),
    "version": (1,2,5)
}

import bpy
from bpy.props import StringProperty
import json

class createAnimation(bpy.types.Operator):
    bl_label = "Create Animation"
    bl_idname = 'object.blendshape_animation_operator'
    
    filepath: StringProperty(name="JSON file", description="JSON blendshape file from Audio2Face", subtype="FILE_PATH")
    
    def execute(self, context):
        # Open JSON file and parse data
        with open(self.filepath) as f:
            json_animate = json.load(f)
                
            bs_animation = json_animate['weightMat']
            bs_pose_count = json_animate['numPoses']
            bs_frame_count = json_animate['numFrames']
            bs_names = json_animate['facsNames']
            bs_offset = 1
            bs_limit = bs_pose_count

            filename = bpy.path.basename(self.filepath)
            
            # Find the Rig object in the selected objects
            selected_objects = bpy.context.selected_objects
            rig_object = None
            
            for obj in selected_objects:
                if obj.type == 'ARMATURE':  # Assuming the rig is an armature
                    rig_object = obj
                    break
            
            if not rig_object:
                self.report({'ERROR'}, "No rig (armature) object found in the selected objects.")
                return {'CANCELLED'}
            
            # Create action on the rig to store keyframes
            action = bpy.data.actions.new(name=filename)
            rig_object.animation_data_create()
            rig_object.animation_data.action = action

            # Create custom properties on the rig for each blendshape name
            for bs_name in bs_names:
                if bs_name not in rig_object.keys():
                    rig_object[bs_name] = 0.0
                    rig_object["_RNA_UI"] = {bs_name: {"min": 0.0, "max": 1.0}}  # Optional UI limits
                
            # Create drivers on shape keys for all non-rig selected objects
            for obj in selected_objects:
                if obj != rig_object and obj.data.shape_keys:
                    shape_key_data = obj.data.shape_keys

                    for j, bs_name in enumerate(bs_names):
                        # Find the corresponding shape key index
                        index = shape_key_data.key_blocks.find(bs_name)
                        if index > -1:
                            # Add a driver for this shape key driven by the custom property on the rig
                            shape_key = shape_key_data.key_blocks[index]
                            driver = shape_key.driver_add("value").driver
                            driver.type = 'SCRIPTED'

                            var = driver.variables.new()
                            var.name = "blendshape"
                            var.targets[0].id = rig_object
                            var.targets[0].data_path = f'["{bs_name}"]'
                            driver.expression = var.name
            
            # Insert keyframes for the custom properties on the rig
            for i in range(bs_frame_count):
                for j, bs_name in enumerate(bs_names):
                    rig_object[bs_name] = bs_animation[i][j]
                    rig_object.keyframe_insert(data_path=f'["{bs_name}"]', frame=i)
            
            # Add the imported file to the scene property
            imported_file = bpy.context.scene.imported_files.add()
            imported_file.name = self.filepath

        return {'FINISHED'}
        
    def invoke(self, context, event):
        context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}

def register():
    bpy.utils.register_class(createAnimation)

def unregister():
    bpy.utils.unregister_class(createAnimation)

if __name__ == "__main__":
    register()
